<application>
  <component name="AppStorage">
    <histories>
      <item value="unhashable" />
      <item value="All values of the `Categorical` are either in `categories` or `np.nan`. Assigning values outside of `categories` will raise a `ValueError`. Order is defined by the order of the `categories`, not lexical order of the values." />
      <item value="Represent a categorical variable in classic R S-plus fashion." />
      <item value="`Categoricals` can only take on only a limited, and usually fixed, number of possible values (`categories`). In contrast to statistical categorical variables, a `Categorical` might have an order, but numerical operations (additions, divisions, ...) are not possible." />
      <item value="maintained." />
      <item value="Operations between Series (+, -, , \\, \\\\) align values based on their associated index values-- they need not be the same length. The result index will be the sorted union of the two indexes." />
      <item value="Labels need not be unique but must be a hashable type. The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index. Statistical methods from ndarray have been overridden to automatically exclude missing data (currently represented as NaN)." />
      <item value="Number of periods to generate" />
      <item value="Left bound for generating dates." />
      <item value="start : str or datetime-like, optional Left bound for generating dates. end : str or datetime-like, optional Right bound for generating dates. periods : int, optional Number of periods to generate. freq : str or DateOffset, default 'D' Frequency strings can have multiples, e.g. '5H'. See :ref:`here &lt;timeseries.offset_aliases&gt;` for a list of frequency aliases. tz : str or tzinfo, optional Time zone name for returning localized DatetimeIndex, for example 'AsiaHong_Kong'. By default, the resulting DatetimeIndex is timezone-naive. normalize : bool, default False Normalize startend dates to midnight before generating date range. name : str, default None Name of the resulting DatetimeIndex. closed : {None, 'left', 'right'}, optional Make the interval closed with respect to the given frequency to the 'left', 'right', or both sides (None, the default)." />
      <item value="Returns the range of equally spaced time points (where the difference between any two adjacent points is specified by the given frequency) such that they all satisfy `start &lt;[=] x &lt;[=] end`, where the first one and the last one are, resp., the first and last time points in that range that fall on the boundary of ``freq`` (if given as a frequency string) or that are valid for ``freq`` (if given as a :class:`pandas.tseries.offsets.DateOffset`). (If exactly one of ``start``, ``end``, or ``freq`` is not specified, this missing parameter can be computed given ``periods``, the number of timesteps in the range. See the note below.)" />
      <item value="glob" />
      <item value="RuntimeError: CUDA error: invalid device ordinal CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect. For debugging consider passing CUDA_LAUNCH_BLOCKING=1." />
      <item value="Tried to allocate 256.00 MiB" />
      <item value="contiguous" />
      <item value="folder path" />
      <item value="INTER NEAREST" />
      <item value="interpolation" />
      <item value="augment" />
      <item value="align corners" />
      <item value="bilinear" />
      <item value="normal" />
      <item value="if bilinear, use the normal convolutions to reduce the number of channels" />
      <item value="inplace" />
      <item value="Double Conv" />
      <item value="clip" />
      <item value="RuntimeError: The size of tensor a (6) must match the size of tensor b (7) at non-singleton dimension 3" />
      <item value="RuntimeError: Given groups=1, weight of size [10, 10, 3, 3], expected input[64, 30, 7, 7] to have 10 channels, but got 30 channels instead" />
      <item value="return F.conv2d(input, weight, bias, self.stride, TypeError: conv2d() received an invalid combination of arguments - got (tuple, Parameter, Parameter, tuple, tuple, tuple, int), but expected one of: (Tensor input, Tensor weight, Tensor bias, tuple of ints stride, tuple of ints padding, tuple of ints dilation, int groups) didn't match because some of the arguments have invalid types: (!tuple!, !Parameter!, !Parameter!, !tuple!, !tuple!, !tuple!, int) (Tensor input, Tensor weight, Tensor bias, tuple of ints stride, str padding, tuple of ints dilation, int groups) didn't match because some of the arguments have invalid types: (!tuple!, !Parameter!, !Parameter!, !tuple!, !tuple!, !tuple!, int)" />
      <item value="Calculated padded input size per channel: (4 x 4). Kernel size: (5 x 5). Kernel size can't be greater than actual input size" />
      <item value="AttributeError: module 'numpy' has no attribute 'from_numpy'" />
      <item value="attribute" />
      <item value="could not convert string '-0.294118,0.487437,0.180328,-0.292929,0,0.00149028,-0.53117,-0.0333333,0' to float32 at row 0, column 1." />
      <item value="ValueError: only one element tensors can be converted to Python scalars" />
      <item value="x and y must have same first dimension, but have shapes (0,) and (1001,)" />
      <item value="UserWarning: size_average and reduce args will be deprecated, please use reduction='sum' instead." />
      <item value="deprecated" />
      <item value="shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {'C', 'F'}, optional Row-major (C-style) or column-major (Fortran-style) order." />
      <item value="&quot;&quot;&quot; ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to a low-level method (`ndarray(...)`) for instantiating an array. For more information, refer to the `numpy` module and examine the methods and attributes of an array." />
      <item value="interpolate" />
      <item value="zeros" />
      <item value="traub" />
      <item value="temp" />
      <item value="You may be wondering what this giant blob of binary data here is, you might even be worried that we're up to something nefarious (good for you for being paranoid!). This is a base85 encoding of a zip file, this zip file contains an entire copy of pip (version 22.2.2). Pip is a thing that installs packages, pip itself is a package that someone might want to install, especially if they're looking to run this get-pip.py script. Pip has a lot of code to deal with the security of installing packages, various edge cases on various platforms, and other such sort of &quot;tribal knowledge&quot; that has been encoded in its code base. Because of this we basically include an entire copy of pip inside this blob. We do this because the alternatives are attempt to implement a &quot;minipip&quot; that probably doesn't do things correctly and has weird edge cases, or compress pip itself down into a single file. If you're wondering how this is created, it is generated using `scriptsgenerate.py` in https:github.compypaget-pip." />
      <item value="Creates a new image with the given mode and size. :param mode: The mode to use for the new image. See: :ref:`concept-modes`. :param size: A 2-tuple, containing (width, height) in pixels. :param color: What color to use for the image. Default is black. If given, this should be a single integer or floating point value for single-band modes, and a tuple for multi-band modes (one value per band). When creating RGB images, you can also use color strings as supported by the ImageColor module. If the color is None, the image is not initialised. :returns: An :py:class:`~PIL.Image.Image` object." />
      <item value="illow==8" />
      <item value="ZeroDivisionError: division by zero" />
      <item value="height" />
      <item value="dilation" />
      <item value="check images and mask" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="131" />
        <entry key="ENGLISH" value="124" />
        <entry key="POLISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="HINDI" value="3" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1671087637061" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200305000393002" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="702e8bcf19a93b80" />
      </youdao-translate>
    </option>
  </component>
</application>